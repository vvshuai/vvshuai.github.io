<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20210521</title>
    <url>/2021/05/21/20210521/</url>
    <content><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>继续苦逼的毕业论文……</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>记ffmpeg不同环境的问题</title>
    <url>/2021/06/03/Reflection-20210603/</url>
    <content><![CDATA[<h1 id="工作中的思考-20210603"><a href="#工作中的思考-20210603" class="headerlink" title="工作中的思考(20210603)"></a>工作中的思考(20210603)</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>遇到一个匪夷所思的问题，使用ffmpeg命令对音视频、图片等进行处理时，本地可以通过接口调用执行cmd返回一段视频，打包后发布到ECS和K8S多台机器后，在sit环境居然直接挂了。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>遂在日志中排查问题，将通过埋点获得的命令在k8s上执行，居然也成功了，从过程上看确实是由于这条命令该生成的文件没有生成，但服务器终端手动执行又执行成功，一模一样的命令通过终端执行和通过Java的exec执行会有区别吗？</p>
<p>按道理来说不会有区别，因为Java本身是一次编译到处执行，并不会受到跨平台的影响，本地也是直接路由到docker镜像上。</p>
<p>还有一种可能是线程池的问题，利用两个线程去跑两个异步任务，有没有可能这个线程被不明原因阻塞，而程序主线程继续执行，导致我们命令执行成功，但文件未写入到服务器中。</p>
<p>也有可能是waitFor方法失效，不过可能性不大。</p>
<p>相同的命令我们在几个环境测试，居然会有不同的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -nostdin -r 25 -y -i 1.jpg -vf &quot;zoompan=&#x27;1.25&#x27;:x=&#x27;if(lte(on,-1),(iw-</span><br><span class="line">iw/zoom)/2,x+20)&#x27;:y=&#x27;if(lte(on,1),(ih-ih/zoom)/2,y)&#x27;:d=150&quot; -c:v libx264 -t 2 -pix_fmt yuv420p 1.mp4</span><br><span class="line">ffmpeg -nostdin -r 25 -y -i 2.jpg -vf &quot;zoompan=&#x27;1.25&#x27;:x=&#x27;if(lte(on,1),(iw/zoom)/2,x-20)&#x27;:y=&#x27;if(lte(on,1),(ih-ih/zoom)/2,y)&#x27;:d=150&quot; -c:v libx264 -t 2 -pix_fmt yuv420p 2.mp4</span><br><span class="line">ffmpeg -nostdin -r 25 -y -i 3.jpg -vf &quot;zoompan=&#x27;1.5&#x27;:x=&#x27;if(lte(on,1),(iw-iw/zoom)/2,x)&#x27;:y=&#x27;if(lte(on,-1),(ih-ih/zoom)/2,y+15)&#x27;:d=150&quot; -c:v libx264 -t 2 -pix_fmt yuv420p 3.mp4</span><br><span class="line">ffmpeg -nostdin -r 25 -y -i 4.jpg -vf &quot;zoompan=&#x27;1.5&#x27;:x=&#x27;if(lte(on,1),(iw-iw/zoom)/2,x)&#x27;:y=&#x27;if(lte(on,1),(ih/zoom)/2,y-15)&#x27;:d=150&quot; -c:v libx264 -t 2 -pix_fmt yuv420p 4.mp4</span><br><span class="line"></span><br><span class="line">ffmpeg -r 25 -y -i 1.jpg -vf &quot;scale=-2:10*ih,zoompan=z=&#x27;min(zoom+0.035,2)&#x27;:d=600:x=&#x27;iw/2-(iw/zoom/2)&#x27;:y=&#x27;ih/2-(ih/zoom/2)&#x27;,scale=-2:720&quot; -c:v libx264 -t 1 -pix_fmt yuv420p 5.mp4</span><br><span class="line"></span><br><span class="line">ffmpeg -r 25 -y -i 3.jpg -vf scale=-2:10*ih,zoompan=z=&#x27;if(eq(ld(1),0),zoom+1-0.035*st(1,1),max(zoom-0.035,1))&#x27;:d=400:x=&#x27;iw/2-(iw/zoom/2)&#x27;:y=&#x27;ih/2-(ih/zoom/2)&#x27;,scale=-2:720 -c:v libx264 -t 1 -pix_fmt yuv420p 6.mp4</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>环境</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>本地ffmpeg执行</td>
<td>成功</td>
</tr>
<tr>
<td>本地Unbuntu20.04执行</td>
<td>成功</td>
</tr>
<tr>
<td>本地启动项目，通过调接口执行</td>
<td>成功</td>
</tr>
<tr>
<td>项目部署到k8s后，在服务器端centos的终端执行</td>
<td>成功</td>
</tr>
<tr>
<td>项目部署到k8s后，通过接口调用</td>
<td>失败</td>
</tr>
</tbody></table>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>今天通过增加日志的分析参数，发现在执行视频放缩时没有找到对应的过滤器，而ffmpeg中ld指令是获取我们在st中的值，查阅官方文档发现我们并没有缺少libavuitl这个库。</p>
<p><img src="https://blog-vs-oss.oss-cn-beijing.aliyuncs.com/img/image-20210604204518926.png" alt="image-20210604204518926"></p>
<p>而后我发现在执行**eq(ld(1),0)<strong>在中间多加一个空格</strong>eq(ld(1), 0)**，想到之前调试到Java的exec源码，顺便分析一下。</p>
<p>首先随便写个main函数,开始单步调试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        String cmd = <span class="string">&quot;java -version&quot;</span>;</span><br><span class="line">        Process cmdProcess = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cmdProcess = runtime.exec(cmd);</span><br><span class="line">            cmdProcess.waitFor();</span><br><span class="line">            cmdProcess.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行进来以后发现首先声明了一个StringTokenizer，然后通过空格拆分，但是考虑到本地Java执行成功，还要继续跟进源码，进入下一个exec函数。</p>
<p><img src="https://blog-vs-oss.oss-cn-beijing.aliyuncs.com/img/image-20210604210400742.png" alt="image-20210604210400742"></p>
<p>exec函数执行了start函数，可以得到如下图所示：</p>
<p><img src="https://blog-vs-oss.oss-cn-beijing.aliyuncs.com/img/image-20210604210919304.png" alt="image-20210604210919304"></p>
<p>这段源码写的很简练，也很精髓，利用Java的万类之王Object，直接克隆对象直接修改，效率很高，接下来就是判断命令是否为空，是否存在权限，是否有不合法字符。</p>
<p><img src="https://blog-vs-oss.oss-cn-beijing.aliyuncs.com/img/image-20210604211219884.png" alt="image-20210604211219884"></p>
<p>现在还没有发现问题所在，继续向下走。</p>
<p><img src="https://blog-vs-oss.oss-cn-beijing.aliyuncs.com/img/image-20210604211419822.png" alt="image-20210604211419822"></p>
<p>最后，我注意到使用了一个枚举，源码注释是”Represents a source of subprocess input or a destination of subprocess output”，明白我们的exec函数其实是创建了一个进程(Process)，这个进程会处理我们的命令，通过返回两个数据流（正常流和ERROR流），将流进行合并返回结果，这里就不写了。</p>
<p>看样子应该是Java创建linux的进程(准确说应该是task_struct)和shell执行有一定出入，也有可能是ffmpeg的bug。</p>
<p>后来在ffmpeg社区中发现有人遇到这个问题，在linux环境下服务器端过滤器不能加引号，整条命令不能有空格，仅限打包到服务器后，其他没有任何问题。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>学习一些开源软件，可以去社区看看结果，撰写命令行不该像写程序一样加空格。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/20/text/</url>
    <content><![CDATA[<h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><h2 id="BootStrap学习"><a href="#BootStrap学习" class="headerlink" title="BootStrap学习"></a>BootStrap学习</h2><h3 id="BootStarp-Table"><a href="#BootStarp-Table" class="headerlink" title="BootStarp-Table"></a>BootStarp-Table</h3><h4 id="1-bootstrap-table设置某列序号自增"><a href="#1-bootstrap-table设置某列序号自增" class="headerlink" title="1.bootstrap-table设置某列序号自增"></a>1.bootstrap-table设置某列序号自增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">col = [&#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;SerialNumber&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;序号&#x27;</span>,</span><br><span class="line">    <span class="attr">formatter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value, row, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
      </tags>
  </entry>
</search>
